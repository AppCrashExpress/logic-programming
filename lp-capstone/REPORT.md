# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Ефимов А.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В.     |    14.12.19          |    5           |
| Левинская М.А.    |              |               |

> Хорошая реализация избавления от дублирующихся решений.

## Введение

Пролог - язык логического программирования, который, в отличие от императивных языков программирования,
основывает поток своего выполнения на поиске с возвратами, унификации и резолюции переменных.
Такой подход позволяет программисту сосредотачивать свое внимание не на выполнении программы
(не создавая циклов и не описывая потока выполнения), а на создании предикатов,
которые описывают условия успешной унификации.

Данный курсовой проект направлен на посвящение студента в языки логического программирования, включая, но не ограничиваясь на:
* Работа с предикатами;
* Рекурсивный поиск в базе данных;
* Определение взаимосвязи между двумя элементами в базе данных;
* Реализация естественно-языкового интерфейса

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление:\
  __parents(потомок, отец, мать)__
 
 3. Реализовать предикат проверки/поиска __тещи__
 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Для создания родословного дерева был использован сервис [MyHeritage.](https://www.myheritage.com/) Оно было заполнено
при помощи генератора имен, причем фамилии подобраны таким образом, чтобы наиболее правдоподобно выражали настоящие
родственные связи. Результирующее дерево имеет 79 индивидуумов.

## Конвертация родословного дерева

Родословное дерево в формате _.ged_ было обработано с помощью языка __Python__, так как он имел объемную библиотеку для
работы со строками, а также позволял создание "_словарей_" – списков пар ключей и слов, что позволяло приписать к паре
"Имя-Фамилия" UID и использовать его при поиске членов семей по UID.
```python
person = {'UID': '', 'Name': '', 'Surname': ''}
```
Дальше происходит построчное считывание файла _.get_. "_@I_" сигнализирует о начале описания нового индивида.
Это и есть начало UID человека. Тогда добавляем в список текущий словарь _person_ и начинаем заполнение нового словаря.
В следующих строках ищется имя и фамилия.

Если вторая буква второго слова равна _F_, то мы дошли до блока семей – заканчиваем заполнять список людей _people_.

После того, как мы дошли до блока семей, перед тем как заходить в него, удалим первый элемент
списка людей (он будет пустой) и создадим переменные для отца, матери и списка детей.
Они инициализированы под "NO_DATA" на случай, если один из членов не найден:
```python
del(people[0]) #When we read the first id, we append empty dictionary. Deleting it...

father = "NO_DATA"
mother = "NO_DATA"
kids = ["NO_DATA"]
```

После этого, начинается построчное считывание блока семей, и после "HUSB", "WIFE", "CHILD" ищутся по UID соответсвенно
отец, мать и дети. Каждая новая семья начинается с цифры индентации "0".

Последним (перед закрытием файлов) выписывается предикат поиска тещи.

## Предикат поиска родственника

Предикат поиска тещи (файл "mother_in_law.pl"): 
```prolog
motherInLaw(Husband, Mom):-
    setof(X, motherInLaw_assist(Husband, X), MomList),
    member(Mom, MomList).

motherInLaw_assist(Husband, Mom):-
    parents(_, Husband, Wife),
    parents(Wife, _, Mom).
```
Для того, чтобы два человека имели отношение муж – теща, необходимо, чтобы у мужа была жена, которая является дочерью
в некоторой семье. Эти условия и являются реализованными в этом предикате. setof/3 нужен в для тех случаев,
когда детей больше двух (для избежания повторения тещь).

Протокол выполнения:
```prolog
?- motherInLaw('Vincent Cruz', X).
X = 'Yvette Caldwell'.
```

## Определение степени родства

Для определения цепочки родства была имплементирован поиск в ширину. При продлении пути в поиске ищутся все ближайшие
к человеку родственники (отец, мать или ребенок).
```prolog
connected(Node, Adjacent):-
    parents(Node, Adjacent, _);
    parents(Adjacent, Node,_);
    parents(_, Node, Adjacent);
    parents(_, Adjacent, Node);
    parents(Node, _, Adjacent);
    parents(Adjacent, _, Node).
```
Таким образом поиск ищет в неупорядоченном графе (каждая вершина может быть достигнута из любой другой).
Из-за потенциально большого количества возможных путей, поиск занимает много времени для цепочек после самой короткой.

После того, как путь был построен, начинается его перебор с самого конца для вывода отношений между выбранными
личностями и стоящими между ними узлами. Результатом будет список отношений начиная с конца
(относительно личности, стоящей в начале пути).

Предикат relative/3 не позволяет найти через отношение, так как он начинает выводить результаты из 
всевозможных путей, что приводит к повторениям.

Протокол выполнения:
```prolog
?- relative(Relation, 'Gary Cruz', 'Vincent Cruz').
Relation = ['grandchild - grandfather', 'child - father'] ;
Relation = ['grandchild - grandfather', 'grandchild - grandmother', 'child - father'] ;
Relation = ['grandchild - grandfather', 'child - father', 'child - mother'] ;
Relation = ['grandchild - grandfather', 'grandchild - grandmother', 'child - father', 'child - mother'] ;
Relation = ['grandchild - grandfather', 'child - father', sibling, 'child - mother'] ;
Relation = ['grandchild - grandfather', 'grandchild - grandmother', 'child - father', sibling, 'child - mother'] ;
false.
```

## Естественно-языковый интерфейс

Каждый из задаваемых вопросов должен вызывать разные функции (например, "Who is child of X" и "Whose father is Y"
будут выполнять разные поиски в базе). Соответственно, для каждого вопроса нужно делать разные проверки.
Для этого был использован DCG./
После того, как запрос был введен, он разбивается на слова с помощью atomic_concat/3,
список слов передается предикату s, который последовательно начинает его перебирать с целью унификации
с одним из возможных шаблонов. Доступные шаблоны:

1. Is X _RELATION_ of Y
2. Does X have a _RELATION_
3. Who is a _RELATION_ of Y
4. Who is X to Y
5. Whose _RELATION_ is X
6. How many _RELATION_ does X have

В случае неудачи обработки возвращается false.

Кроме того, каждый из них отдельно поддерживает местоимение 'they' (использовано нейтральное местоимение ввиду
затруднений с определением пола). Запоминание прошлого использованного имени было создано используя предикат asserta/1.
Если в новом запросе не было использовано местоимение, то его текущее значение перезаписывается с помощью reassert/2
(проверяющий использование значения и перезаписывающий в случае чего):
```prolog
reassert(X, Y):-
    prev(X);
    prev(Y);
    retractall(prev(_)),
    asserta(prev(X)), !.
```
Приоритет перезаписи настроен вручную (т.е. для вопросов 1 и 4 приоритетами является X, так как Y не является главным).

Предикат get_n ищет имя и дополнительно имеет три настройки для предшествующих вспомогательных глаголов:
1. Если предшествующий глагол должен быть do/does
2. Если is/are
3. Если предшествующего глагола нет (случаи "of Y" или "to Y").

Предикат get_r обрабатывает слова, обозначающие отношения, учитывая возможные их вариации.

Вызов запроса происходит с помощью предиката inquire(+Sentence, -Answer).\
Протокол выполнения:
```prolog
?- inquire('Who is a grandmother of Gary Cruz', Ans).
Ans = ['Beatrice Cruz', 'Mattie Sanchez'].

?- inquire('Who is their sibling', Ans).
Ans = ['Edgar Elliott'].

?- inquire('Do they have a mother-in-law', Ans).
Ans = 'No'.

?- inquire('Who is Maggie Hogan to Vincent Cruz', Ans).
Ans = grandmother.

?- inquire('Who is Vincent Cruz to them', Ans).
Ans = grandchild.
```

## Выводы

Данная курсовая работа помогла выявить сильные стороны пролога, такие как бэктрекинг и унификация, которые значительно
уменьшили потенциальные размер кода и упростили создание поиска в базе данных из-за заранее имплементированного перебора.
Кроме того, в ней были использованы элементы естественно-языковой обработки, позволяющие принимать запросы в виде вопросов
и делать осмысленные ответы на них.
