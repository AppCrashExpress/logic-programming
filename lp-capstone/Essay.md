# Реферат
## по курсу "Логическое программирование"

### студент: Ефимов А.В.

## Логические языки и базы данных

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В.     |              |               |
| Левинская М.А.    |              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

До эпохи компьютеров большая часть данных (например, для магазинов – данных о товарах, их ценах, количествах; для банков –
содержимое аккаунтов клиентов, счета, транзакции и т.д.) хранилась на бумаге, что сильно ограничивало возможный объем
хранимых данных. Но с появлением нового способа хранения информации в
виртуальном виде увеличился и объем данных. Получавшиеся базы данных (особенно в крупных компаниях) имели размеры,
которые не позволяли быстро выводить нужную информацию вручную. Для упрощения доступа к стремительно растущим базам
данных и работы с ними требовалась помощь от языков программирования.  

## Базы данных

Под базой данных принимается некоторые коллекции данных, организованные и связанные между собой по ключам.
Самый простой способ их представления – в виде таблицы. Он предоставляет вывод информации по ключу (например, имени
или ID) и позволяет пользователю получить прямой доступ ко всем данным, связанными с этим ключом. Такой способ
применяется для работы с небольшими таблицами данных, расчитанными на одного или несколько человек. Однако, для
больших объемов данных он становится сложных в применении из-за громоздких объемов таблицы и требует ее дополнительного
разбиения на подтаблицы. В связи с этими, такие коллекции чаще всего представляются в виде реляционных баз данных –
множество таблиц, содержащих в себе данные, которые связаны между собой одним или несколькими общими полями.
Пример: одна таблица содержит в себе ID программиста, его ФИО и адрес электронной почты,
а другая – также его ID и назначенный ему проект. Такой подход структуризирует данные в более доступный формат для
машины, но менее доступный формат для человека (для больших баз данных требуется последовательно перебрать таблицы даже
используя поиск по ключу, если общие поля между таблицами отличаются). Такую проблему помогают решать
логические языки программирования, в частности prolog.

## Логические языки программирования

Логические языки программирования являются частью декларативной парадигмы программирования – прямой противоположности
императивной парадигмы. В декларативной парадигме программист описывает проблему и ожидаемый результат, в то время
как в императивной описывается как добиться этого результата (поток программы).\
Логический язык строится на использовании дизъюнкты Хорна – логические факты и правила, которые образуют
предикаты, – чтобы описать какую-то область проблемы, и обрабатывает запросы, используя написанную базу предикат.\
Правила в логическом программировании имеют формат:
```
H :- B1, B2, ..., BN.
```
что читается как
```
Если B1 и B2 и ... и BN то H.
```
где H называется головой, а B1 ... BN - телом правила. Факты - это правила без тела.

Соответственно, чтобы решить какой-либо запрос, необходимо последовательно обойти каждое из правил тела. В логических
языках порядок обхода правил может различаться между языками.

### Prolog

Prolog – возможно наиболее известный и используемый из логических языков. Также как и другие языки, он способен
задавать факты и правила. Один из наиболее популярных примеров, приводимых для показания синтаксиса языка prolog,
являются три предложения:
```
Все люди смертны.
Сократ – человек.
Значит, Сократ смертный.
```
Что переводится в язык prolog как:
```prolog
mortal(X):- man(X).
man(socrates).

?- mortal(socrates).
true.
```
Первая строка является правилом, так как у нее есть тело (или условие). Вторая строка не имеет тела, что делает ее
фактом, выполняющимся всегда. Последние две строчки являются запросом в интерпретаторе языка (для Prolog существует
несколько имплементаций; приведен пример из SWI-Prolog) и его результатом.

При выполнении запросов prolog строит дерево из правил и обходит его в порядке "первый вошел - последним вышел".
Такой порядок обхода придает ему следующие особенности:

* Унификация – если правилу соответствует множество решений, то prolog берет одно из этих решений,
создавая при этом точку выбора, и продолжает работу;
* Бэктрекинг – если использовано решение, при котором не выполняется правило (или пользователь запросил больше решений),
то prolog возвращается к прошлой точке выбора и начинает искать новые возможные решения;
* Рекурсия – правило может вызвать само себя, создавая таким образом итеративность.

С помощью этих особенностей реализуется стратегия резолюции – доказательства запросов путем доказательства их правил,
от которых они зависят, и правил этих правил. 

### База данных в prolog

Логической базой данной является некоторая база данных, отношения между данными в которой описаны с помощью правил и фактов.
Рассмотрим несколько основных методов, которые помогут разработать простую базу на языке prolog.\
Перед ее созданием перечисляются некоторое множество фактов, которое задает основу, по которой будут создаваться заключения.\
Пример фактов из родственного дерева:
```prolog
male(edgar).   
male(gary).    
male(isaac).   
male(lester).
male(vincent).
male(lester).

female(mattie).
female(beatrice).
female(patty).

mother(patty, edgar).
mother(patty, gary).
mother(beatrice, isaac).
mother(mattie, lester).
mother(mattie, patty).

father(isaac, edgar).
father(isaac, gary).
father(vincent, isaac).
father(luke, lester).
father(luke, patty).
```

#### Задание отношений

Названия предикатов говорят за себя – male и female говорят о поле человека, mother(A, B)/father(A, B) обозначают,
что A является матерью/отцом B. Эти предикаты задают отношения между двумя людьми. На основе этих отношений можно
создавать и другие, моделируя таким образом отношения реального мира. Например, известно, что пара детей одного
человека будут братьями/сестрами. На основе этого можно описать новые отношения:
```prolog
brother(Brother, Child):-
    mother(Mother, Child),
    mother(Mother, Brother).
```
На основе созданных отношений можно создавать другие отношения, позволяя разбивать сложное на более простое. К примеру,
известно, что ребенку человек будет дядей, если он брат одного из родителей. Тогда
```prolog
uncle(Uncle, Child):-
    mother(Mother, Child),
    brother(Uncle, Mother);
    father(Father, Child),
    brother(Uncle, Father).
```

#### Нестандартные отношения 

Из этой базы данных можно задавать и нестандратные отношения. Например, предположим, что мы живем в идеальном мире.
Тогда, из того, что у двух людей есть ребенок, можно сделать умозаключение, что они – супруги:
```prolog
married(Man, Woman):-
    mother(Woman, Child),
    father(Man, Child).
```
Как видно, создание базы данных состоит в задании нужных и возможных отношений между данными фактами.
Отношения наподобие того, что выше, показывают новые подходы обращения к базе данных и помогают вывести информацию,
которую пришлось бы выводить вручную.

#### Структурирование данных

Отношения не ограничиваются на отношениях между людьми. Это могут быть отношения вида ключ-слово (в поиске),
дата-время-событие и т.д. При задании длинных цепочек отношений необходимо верно подбирать структуру данных.
Например, прошлую цепочку дата-время-событие можно задать в виде
```prolog
planned(year, month, day, hour, minute, event).
```
Такой предикат имеет 6 арность (количество аргументов предиката). Но его можно преобразовать в предикат 3 арности:
```prolog
planned(date(year, month, day), time(hour, minute), event).
```
Здесь предикат planned имеет 2 сложных термина и один простой. Правильное задание структуры данных значительно упрощает
дальнейший их поиск, а также написание других отношений, на основе этих. Например, вот реализация поиска
даты по названию события для planned/3 и planned/6.
```prolog
% Для planned\3
date_of_event(Year, Month, Day, Event):-
    planned(date(Year, Month, Day), _, Event).

% Для planned\6
date_of_event(Year, Month, Day, Event):-
    planned(Year, Month, Day, _, _, Event).

% Нижнее подчеркивание означает, что в этой позиции есть аргумент, но он не является нужным.
```
Как видно из примера, первое представление выглядит не только проще, но и логичнее (связанные данные год, месяц и день
группируются вместе).

#### Рекурсивные правила

Некоторые отношения возможно задавать из самих себя.\
Вернемся к базе данных, составленного из родственного дерева. В нем можно увидеть, что у Edgar есть мать Patty,
а у неё есть мать Mattie. Соответственно у Edgar есть предок Patty, у которой есть предок Mattie. Наблюдается рекурсия,
которую можно задать правилом:
```prolog
ancestor(Person, Ancest):-
    parent(Person, Parent),
    ancestor(Person, Ancest).
```
Но это правило не будет выполняться, так как для его выполнения нужно, чтобы выполнялись его два правила. Но, если
дойдем до нужного предка, то вторая строка не будет выполняться, так как мы будем пытаться искать его в качестве
родителя самого себя. Значит необходимо добавить базовое условие:
```prolog
ancestor(Ancest, Person):-
    parent(Ancest, Person).
```
Причем, так как prolog выполняет предикаты в порядке их расположения в базе, в некоторых случаях порядок их
расположения становится важным. В данном случае (если расположить их именно в том порядке, в котором они были введены)
после того, как первый предикат провалился, выполняется второй (порядок безразличен).
Но если выразить предикаты в следующем виде:

```prolog
ancestor(Ancest, Person):-
    parent(Ancest, Person), !. % Оператор отсечения, нужный для прекращения рекурсии

ancestor(Ancest, Person):-
    ancestor(Ancest, Parent), % Головная рекурсия
    parent(Parent, Person).
```
То, поменяв местами первый и второй предикат, получаем бесконечный вызов предикатом самого себя. Учитывая это,
при работе с рекурсией (прямой и косвенной) следует учитывать расстановку предикатов.
Правильно составленные предикаты дают нам рекурсивные правила,
которые позволяют найти отношения в длинных цепочках информации.

#### Операции реляционных баз данных в логических программах

Для реляционных баз данных свойственны 6 операций (операций алгебры отношений):
1. Выборка

Выборка – отношение, выводящее все данные, которые соответствуют поставленным условиям. В логических программах она будет иметь вид
```
r_sel(X1, ..., Xn):- r(X1, ..., Xn), condition(X1, ..., Xm).
```
где r_sel – некоторый предикат, задающий отношение выборки, r – существующее отношение базы или факт, condition – предикат,
проверяющий выполнение данными факта некоторого условия. Для предиката факта арности n предикат условия может
иметь арность 1<=m<=n (при арности равной нулю условие не зависит от данных,
при арности больше n появляются пустые аргументы). 

Здесь и далее примеры будут показаны на ранее приведенном предикате planned/3:
```prolog
no_morning(Year, Month, Day, Hour, Minute, Event):-
    planned(date(Year, Month, Day, Hour, Minute, Event)),
    Hour >= 10.
```
Здесь происходит вывод (или выборка) всех событий, которые происходят в 10 и позже часов.

2. Проекция

Проекция подразумевает создание нового отношения путем выделения некоторых данных из других отношений или фактов.
```
r_proj(X1, ... Xm):- r(X1, ..., Xn).
```
Также, как и в выборке, 1<=m<=n, иначе будет присутствовать никогда не унифицирующиеся аргументы.

Пример:
```prolog
month_of_event(Month, Event):-
    planned(date(_, Month, _), _, Event).
```
Выводит все события и месяц, в котором они происходят.

3. Объединение

Под объединением двух предикатов принимают все данные, которые соответствуют или первому, или второму предикату.
```
r_union(X1, ..., Xn):- r1(X1, ..., Xn).
r_union(X1, ..., Xn):- r2(X1, ..., Xn).
```
Важным условием является, чтобы и r1, и r2 были одинаковой арности.
Пример:
```prolog
all_events(Date, Time, Event):- planned(Date, Time, Event).
all_events(Date, Time, Event):- completed(Date, Time, Event).
```
Выводит все события, прошедшие и будущие.

4. Пересечение

Пересечение возвращает данные, которые верны и для первого, и для второго предиката.
Как и у объединения, арности должны быть равны.
```
r_intersect(X1, ..., Xn):-
    r1(X1, ..., Xn),
    r2(X1, ..., Xn).
```
Пример
```prolog
will_visit(Date, Time, Event):-
    friend_plan(Date, Time, Event),
    my_plan(Date, Time, Event).
```
Выводит все события, которые планируются одновременно и кем-то, и его другом.

5. Вычитание

Под вычитанием принимается отношение, которое возвращает список данных отношения 1, не имеющий данных из отношения 2.
```
r_diff(X1, ..., Xn):-
    r1(X1, ..., Xn),
    not(r2(X1, ..., Xn)).
```
Следует не путать отношения пересечения и вычитания, так как пересечение возвращает данные,
общие для первого и второго отношений, а вычитание – данные, соответствующие первому
отношению и не соответствующие второму.

Пример:
```prolog
completed(Date, Time, Event):-
    all_events(Date, Time, Event),
    not(planned(Date, Time, Event)).
```
Предикат возвращает все события, которые уже произошли путем взятие разницы между всеми событиями и произошедшими событиями.

6. Декартово произведение

Декартово произведение выводит комбинацию данных отношения 1 арности n и данные отношения 2 арности m.
```
r_cartesian(X1, ..., Xn, Xn+1, ..., Xn+m):-
    r1(X1, ..., Xn),
    r2(X1, ..., Xm).
```
В отличие от операции объединения, декартово произведение может возвращать все возможные комбинации данных, даже независимых.\
Эта операция существует в базах данных для вывода сразу несколько таблиц.

Пример
```prolog
events(Date1, Time1, Event1, Date2, Time2, Event2):-
    planned(Date1, Time1, Event1),
    completed(Date2, Time2, Event2).
```

Предикат выдает перестановки данных таблицы спланированных событий и таблицы произошедших событий.

Сами по себе операции не смогут вернуть большое количество полезной информации. Для того, чтобы создать правила,
которые способны выводить полезную и определенную информацию, можно комбинировать между собой результаты
операций.

Пример:

Для того, чтобы расширить ранее заданное отношение will_visit/3, можно ограничить выводимое время до 10 утра и более.
Тогда можно одновременно применять операции объединения и выборки:
```prolog
will_visit(Date, time(Hour, Minute), Event):-
    friend_plan(Date, time(Hour, Minute), Event),
    my_plan(Date, time(Hour, Minute), Event).
    Hour >= 10.
```

Для того, чтобы уменьшить количество выводимых данных, например до вывода дня и события, можно использовать операцию проекции:
```prolog
will_visit(Day, Event):-
    friend_plan(date(Year, Month, Day), time(Hour, Minute), Event),
    my_plan(date(Year, Month, Day), time(Hour, Minute), Event).
    Hour >= 10.
```

## Заключение

Язык prolog имеет все необходимые инструменты, которые позволяют с нуля написать собственную реляционную базу,
а также задать отношения между данными в ее таблицах. Особенности prolog, такие, как бэктрекинг и унификация позволяют
последовательно обходить факты в порядке их появления и автоматически проверять запросы пользователя на выполнение,
в случае чего выводить полученную информацию в виде унифицированных переменных.

## Библиография
1. [Теория баз данных и основные определения](https://mariadb.com/kb/en/library/database-theory/)
2. [Логическое программирование (страница Wikipedia)](https://en.wikipedia.org/wiki/Logic_programming)
3. The Art of Prolog, Leon Sterling, Chapter 2.
4. [Понятия реляционной алгебры](https://www.tutorialspoint.com/dbms/relational_algebra.htm)