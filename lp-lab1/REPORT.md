# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### Студент: Ефимов А.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   27.10      |     5-        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки, предоставленные в прологи, имеют ряд ограничений, такие как невозможность за один цикл обратиться к глубокому элемнту, стоящиму в самом конце, по сравнению с более известными языками, как С, Python и т.д.
Однако следует их воспринимать скорее не как списки, а как стеки - обращение к самому верхнему элементу/элементам, рекурсивный перебор элементов...

## Задание 1.1: Предикат обработки списка

#### Через стандартные предикаты

```prolog
cutDefault(List,N,Res):-
    appnd(Res, _, List),
    len(Res, N), !.
```
Простая реализация, позволяющая найти разрезанный список путем перебора через _appnd/3_ так, чтобы найденный результат перебора совпадал с нужным нам размером отрезанного списка

Примеры работы:
```prolog
?- cutDefault([a,b,c,d,e,f,g], 0, Result).
Result = [].

?- cutDefault([a,b,c,d,e,f,g], 4, Result).
Result = [a, b, c, d].

?- cutDefault([a,b,c,d,e,f,g], 7, Result).
Result = [a, b, c, d, e, f, g].

?- cutDefault([a,b,c,d,e,f,g], 8, Result).
false.

?- cutDefault([a,b,c,d,e,f,g], N, [a,b,c,d]).
N = 4.
```

#### Без стандартных предикат

```prolog
listLen([], 0).
listLen([_|T], X1):-
  listLen(T, X),
  X1 is X + 1.

lastPeek([], [], _).
lastPeek([H|T], [Prev|List], Prev):-
    lastPeek(T, List, H).

lastDelete([H|T], Res):-
    lastPeek(T, Res, H).

cutLast(Res, 0, Res).
cutLast(List, N1, Res):-
    lastDelete(List, Temp),
    cutLast(Temp, N, Res),
    N1 is N + 1.

cut(List, N, Res):-
    listLen(List, Size),
    DeleteAmount is Size - N,
    cutLast(List, DeleteAmount, Res), !.
```

В этом случае предикат выполняется за счет последовательного удаления конечных элементов.

__listLen/2__ высчитывает длину списка, __lastPeek/3__ и __lastDelete/2__ удаляют один последний элемент из списка, __cutLast/3__ - удаляет последние Size - n, где n - количество, а Size - начальный размер списка.
Предикат __cut/3__ высчитывает количество элеметов, которое нужно удалить и вызвает рекурсивный предикат _сutLast_.

Примеры:
```prolog
?- cut([a,b,c,d,e,f], 3, Result).
Result = [a, b, c].

?- cut([a,b,c,d,e,f], 0, Result).
Result = [].

?- cut([a,b,c,d,e,f], 6, Result).
Result = [a, b, c, d, e, f].

?- cut([a,b,c,d,e,f], 7, Result).
false.
```

## Задание 1.2: Предикат обработки числового списка

#### Через стандартные предикаты

`minPosDefault(List, Pos):-
    min_list(List, X),
    nth0(Pos, List, X). %nth for GNU prolog
`
__min_list/2__ ищет минимальный элемент, а __nth0__ дает все позиции элементов, равных минимальному (индексация с нуля).

Пример:
```prolog
?- minPosDefault([5,2,6,7,8,5,2], Pos).
Pos = 1 ;
Pos = 6.

?- minPosDefault([3,3,3,3,3,3,3], Pos).
Pos = 0 ;
Pos = 1 ;
Pos = 2 ;
Pos = 3 ;
Pos = 4 ;
Pos = 5 ;
Pos = 6.

?- minPosDefault([], Pos).
false.
```

#### Без стандартных предикат
```prolog
compMin([], Min, Min).
compMin([H|T], Curr, Min):-
    Curr > H,
    compMin(T, H, Min);
    Curr =< H,
    compMin(T, Curr, Min).

min([H|T], Num):- compMin(T, H, Num).

findPos([Num|_], Num, 0).
findPos([_|T], Num, Pos1):-
    findPos(T, Num, Pos),
    Pos1 is Pos + 1.

minPos(List, Pos):-
    min(List, Num),
    findPos(List, Num, Pos).
```

Предикат, выдающий решение,  __minPos/2__ зависит от других предикатов: __compMin/3__ и __findPos/3__. _compMin/3_ высчитывает минимально возможный элемент в списке,
а _findpos/3_ выдает его позицию (в том числе и элементов, равных ему).

Примеры:
```prolog
?- minPos([5,2,6,7,8,5,2], Pos).
Pos = 1 ;
Pos = 6 ;
false.

?- minPos([3,3,3,3,3,3,3], Pos).
Pos = 0 ;
Pos = 1 ;
Pos = 2 ;
Pos = 3 ;
Pos = 4 ;
Pos = 5 ;
Pos = 6 ;
false.

?- minPos([], Pos).
false.

?- minPos([-3, 1, 9, 0], Pos).
Pos = 0 ;
false.
```

#### Совместное использование

Предположим, что у нас есть система, которая возвращает цифры выполнения программ и отдельный список данных. Если же мы получаем -1, то все последуюшие данные могут быть ошибочными в связи с ошибкой обработки системы. 

Тогда можно составить предикат, ищущий отрицательное число и обрезающий список до него:
```prolog
checkError([H|_], 0):- H < 0, !.
checkError([_|T], Pos1):-
    checkError(T, Pos),
    Pos1 is Pos + 1.

cutError(List, Res):-
    minPos(List, Pos),
    checkError(List, Pos),
    cut(List, Pos, Res), !;
    Res = List.
``` 
Примеры: 

```prolog
?- cutError([4,5,3,8,2,0,4,0], Res).
Res = [4, 5, 3, 8, 2, 0, 4, 0].

?- cutError([4,5,3,-1,2,0,4,0], Res).
Res = [4, 5, 3].

?- cutError([], Res).
Res = [].
```

## Задание 2: Реляционное представление данных

Таблицы могут делится на _реляиционные_ и _нереляиционные_. В нереляционных таблицах все данные вложены в нее саму (например, в данном задании таблица стала бы нереляционной, если бы были заменены ключи 'LP', 'PSY'... на соответствующие им названия предметов с последующим удалением предикатов __subject/2__).

Реляционные таблицы - это таблицы, разделенные на несколько подтаблиц. При этом эти таблицы связаны между собой с помощью использования данных как ключей. К примеру в данном задании, прочитав из списка оценок любой предикат grades/2, с помощью ключа из первого поля можно получить название предмета из таблицы _subjects_.

Их особенности становятся и преимуществами, и слабостями в зависимости от намерения их использования: нереляционные таблицы делают их читабельными для обычного пользователя, но менее доступной для программы из-за необходимости перебора большого числа данных для нахождения нужных.

С другой стороны, разбития таблицы на несколько таблиц (что делает ее реляционной) значительно усложняет читабельность для обычного пользователя из-за необходиости сравнения ключей и данных, но понижает нагрузку на программу из-за уменьшения числа перебираемых данных при поиске (если в ней изначально заложены указатели на необходимые таблицы).

---

Каждое из подзаданий выполнено через единственный предикат, но для начала необходимо рассмотреть вспомогательные предикаты, на которых они опираются:

```Prolog
findByNameR([grade(Name, Grade)|T],X,Y):-
    Name = X,
    Grade = Y; % Тут стоит или
    findByNameR(T,X,Y).

findByName(Subject,Grade):-
    student(_, _, List),
    findByNameR(List,Subject,Grade).
```

__findByName/2__ является оберточным предикатом для __findByNameR/2__. Оберточный предикат перебирает все списки оценок, в то время как внутренний предикат ищет в этих списках нужную оценку (или перебирает их). Причем если ему не удается найти нужную нам оценку, он снова вызывает сам себя (что и создает перебор).

```Prolog
getGroups(List):-
    findall(Group, student(Group,_,_), L),
    sort(L, List).
```
__getGroups/1__ выдает упорядоченный список всех групп в таблице _student_.

```Prolog
failed([], _):- fail.
failed([H|T], Bool):-
    H = grade(_, 2),
    Bool is 1, !;
    failed(T, Bool).

failedWrapper(Group, Bool):-
    student(Group, _, List),
    failed(List, Bool).
```
__failedWrapper/2__ является оберточным для __failed/2__. Обертка пребирает все списки оценок выбранной группы и вызывает внутренний предикат, который в свою очередь ищет неудовлетворительную оценку, выдает число 1 при нахождении или вызывает предикат _fail/0_, обозначающий неудачу.

#### Вариант 2
##### Напечатать средний балл для каждого предмета
```prolog
average(Y, Res):-
    subject(X,Y),
    bagof(Grade, findByName(X,Grade), GradeList),
    length(GradeList, Size),
    sum_list(GradeList, Sum),
    Res is Sum / Size.
```
Предикат __average/2__ создает список оценок для какого-либо предмета с помощью __bagof/3__, высчитывает сумму всех оценок и делит его на длину полученного списка, что позволяет найти среднее значение для каждого предмета.

#### Для каждой группы, найти количество не сдавших студентов
```prolog
failedStudents(Group, Sum):-
    bagof(Bool, failedWrapper(Group, Bool), BoolVector),
    len(BoolVector, Sum).
```
Предикат __failedStudents/2__ ищет количество несдавших студентов путем создания списка из единиц с помощью комбинцации предикатов _bagof_ и _failedWrapper_. Их результатом будет список из единиц, количство которых равно коичеству несдавших студентов для группы. Длина этого списка высчитывается с помощью __len/2__.

#### Найти количество не сдавших студентов для каждого из предметов
```prolog
failedBySubject(Name ,Sum):-
    subject(Nickname, Name),
    findall(2, findByName(Nickname, 2), GradeList),
    length(GradeList, Sum).
```
Предикат __failedBySubject/2__ ищет количество неудовлетворительных оценок с помощью __findall/3__, который действует также, как и _bagof_, но, в отличии от последнего, при ненахождении элементов выдает пустой список. Длина полученного списка _GradeList_ и есть количество неудовлетворительных оценок.

## Выводы

Следующий вывод следует рассматривать как собственные мнение.

Несмотря на его потенциал, пролог показался мне чрезмерно замысловатым. Остутствие переменных как таковых, их замена на функторы и унификацию сильно усложнило казалось-бы такую тривиальную задачу, как поиск минимальных элементов или неудовлетворительной оценки.

Пролог как язык програмированния имеет слишком узкую специализацию и не! является неудобным (двойное отрицание исказило смысл фразы?), что делает его непопулярным. Однако, то же время, он помогает развить новую точку зрения при написании кода на других языках, в частности при применении рекурсии и даже при программировании шаблонов (Template programming).
