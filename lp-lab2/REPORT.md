# Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Ефимов А.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   5.11       |      5-       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
Оценка сложности алгоритма (эффективность, непротиворечивость)

## Введение

  Чаще всего, логические задачи построены путем задания какой-то базы и правил, которые образуют ограничения между объектами этой базы. Такие задачи решаются путем выбора некоторых объектов, создания некоторой связи между ними и проверки, если эти связи удовлетворяют заданным правилам. Обобщая, эти задачи решаются методом перебора. Для небольших задач этот метод является неплохим способом решения, даже устно. Но для больших задач памяти человека становится недостаточно и ему приходится прибегать к внешним источникам записи и чтения (в частности, к бумаге). Это является основой решения с помощью сетки (grid-based puzzle solving).
  
  Именно в этом и хорош _prolog_ - __перебор__ является его основной функцией и, для правильно созданной базы и верно расписанных правил, _prolog_ может сделать перебор, самостоятельно согласуя подобранные связи с поставленными правилами.

## Задание

Может быть, вы и не поверите, но в одном городке жили два чудака: Чук и Гек. 

Чук совершенно не мог говорить правду по понедельникам, вторникам и средам, хотя в остальные дни он неизменно был правдив. 

А Гек врал по вторникам, четвергам и субботам, но в другие дни он говорил только правду. 

Как-то я повстречал эту неразлучную пару и спросил одного из них:
 -Скажи пожалуйста, как тебя зовут?
Тот без малейшего колебания ответил: 
 -Чук. 
 -А скажи-ка мне, какой сегодня день недели?
 -Вчера было воскресенье, -- сказал мой собеседник. 
 -А завтра будет пятница, -- добавил его приятель.
 -Подожди, как же так?, -- изумился я, обращаясь к приятелю моего собеседника.
 -Ты уверен, что говоришь правду?
 -Я всегда говорю правду по средам, -- услышал я в ответ. 

Решив, что больше со мной говорить не о чем, приятели пошли дальше, оставив меня в полном недоумении.
Но, подумав, я все-таки сообразил, кто из двух друзей был Чук, а кто Гек.
Между прочим, по разговору можно установить и день недели, в который я встретился с ними. Попробуйте сообразить и вы.

## Принцип решения

  Сам код разбит (с помощью комментариев) на блоки. 
  #### The go-getter
  Самый верхний блок состоит из одного предиката _solve/3_:
```prolog
solve(Speaker, Buddy, Days):-
    statement1(Speaker, SLie),
    other(Speaker, Buddy),
    statement2(Buddy, BLie),
    possible_days(Speaker, SLie, Buddy, BLie, Days).
```
На самом деле, не смотря, что он принимает три переменные, все три переменные будут подсчитаны при вызове самого предиката. Соответсвенно, для получения ответа, достаточно вызвать этот предикат с переменными:
```prolog
 ?- solve(Speaker, Buddy, Days).
```
Speaker выдает имя человека, с которым начинается диалог. Соответственно, Buddy возвращает имя его друга. Days выдает все возможные дни, на которых может идти диалог (хотя для этой задачи решением является один день).

### Facts block
Во втором блоке - блоке фактов - задаются предикаты, которые задают основу задачи. _days/1_ просто возвращает список дней, _lies_fact/2_ обозначает, кто и на каких днях врет.

### Statements block
В третьем блоке - блоке утверждений - заданы утверждения, сказанные Чуком и Геком.

Первый предикат _statement1/2_ проверяет первое утверждение "Чука". С помощью предиката из блока вспомогательных предикатов (_Auxillary predicates_) _adj/2_, который возвращает два рядом стоящих дня (что позволяет найти завтрашний и вчерашний дни), находится день который идет за воскресением и если "Чук" в этот день врет (а так как он в этот день врет этот предикат вернет Гек и что он врет).

Второй и третий предикаты работают в таком же порядке, за исключением того, что из лжи третьего утверждения следует лож второго.

### Auxillary predicates
Последний блок состоит из пяти вспомогательных предикатов, один из которых уже описан.

Предиакт _other/2_ просто возвращает имя другого чудака.

Предикат _lies/2_ по имени выдает дни, на котороых чудак врет.

Предикат _no_lies/2_ соответсвенно возвращает дни, в которых они говорят правду.

Последний предикат, _possible_days/5_, берет четыре аргумента - имена чудаков и соответсвенно врут ли они или нет. Тогда он выдает список дней, на которых это может происходить. Например,
```prolog
 ?- possible_days(chuk, no, gek, yes, Days).
 Days = [thu, sat].
```
что говорит нам, что по четвергам и по субботам Чук говорит правду, а Гек врет.

### Возвращение к _solve/3_
Рассмотрев предикаты, последовательно объясню, что делает _solve/3_.

Первый предикат вернет нам имя Гек и то, что он врет. Действительно, сегодня понедельник (т.к. по словам "Чука" вчера было воскресение), а по понедельникам Чук врет, остается то, что это Гек и что он врет.

Следующий предикат говорит, что имя другого чудака - Чук.

Третий предикат одновременно проверяет третье и второе утверждение. Так как нам изветстно, что третье утверждение говорит Чук (что по средам он всегда говорит правду) и то что он по средам врет, соответственно второе утверждение также лож, а сам он врет.

Последний предикат просто ищет дни, на которых они оба врут, и возвращает единственный день - вторник.
```prolog
 ?- solve(Speaker, Buddy, Days).
 Speaker = gek,
 Buddy = chuk,
 Days = [tue].
```
## Выводы

Как видно, пролог способен также, как и человек, путем перебора (хотя его тут как такового нет), сравнения и исключения решать логические задачи благодаря его _backtracking_'у. В частности, задачи с большим числом переборов (та же популярная загадка зебры) может быть решена с помощью пролога, не прибегая к ручному перебору всех возможных решений. Тем не менее, для этого требуется верно строить правила, по которым и будут происходить сравнения, иначе попытка решения на прологе займет гораздо больше времени, чем решение вручную, а в худшем случае можно прийти к решению, которое на вид кажется верным.



