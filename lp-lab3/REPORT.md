# Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Ефимов А.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В.     |              |               |
| Левинская М.А.    |   4/12       |      3        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В отличие от предыдущей лабораторной, где вся система находилась в единственном состоянии, в этой работе состояния системы изменяются за счет перебора и образования новых, удовлетворяющих поставленным условиям, и для нахождения пути между ними необходимо найти все промежуточные состояния.\
Пролог в данном случае помогает не только перебором этих состояний, но и их записью в память, что позволяет ему вернуться в прошлые состояния в случае прихода в неверное/неподходящее состояние.

## Задание

![task](https://github.com/MAILabs-Education-LP/lp-lab-3-AppCrashExpress/blob/master/task.png)

Вдоль доски расположены лунки, в каждой из которых лежит черный или белый шар. Одним ходом можно менять местами два соседних шара. Добиться того, чтобы сначала шли белые шары, а за ними - черные.
Решить задачу за наименьшее число ходов.

## Принцип решения

#### Интерфейс
Из задания следует, что поиск в глубину следует исключить, так как такой поиск не сможет найти кратчайший путь (если заранее неизвестно, за сколько шагов можно перейти к нужному состоянию). Соответственно, необходимо использовать поиск в ширину, так как из его свойств следует, что при обходе всех вершины состояний на одной высоте первая удовлетворяющая вершина соответствует самому короткому пути:

```prolog
% bfs_search(+Init, +Goal, +Limit, -Path)
bfs_search(Init, Goal, Limit, Node):-
    bfs([[Init]], Goal, Limit, ReversePath),
    reverse(ReversePath, Path).
```
Предикат __bfs_search\4__ является интерфейсом и вызывается с аргументами начальное состояние, конечное, предел по глубине (в таком порядке) и переменной, в которую будет выводиться первый найденный путь. В сам поиск передается список списков, так как вместе с очередью вершины необходимо хранить и сам путь к ней (т.е. список путей).

#### Поиск
```prolog
bfs([[Goal|Path]|_], Goal, _, [Goal|Path]):- !.

bfs([First|Queue], Goal, Limit, RevPath):-
    length(First, Size),
    Size =< Limit,    
    findall(X, prolong(First, X), New),
    append(Queue, New, Queue1), !,
    bfs(Queue1, Goal, Limit, RevPath).

bfs([_|Queue], Goal, Limit, RevPath):-
    bfs(Queue, Goal, Limit, RevPath).
```
Сама имплементация поиска. Первое правило необходимо для обнаружения и вывода подходящего пути, последнее нужно для исключения ненужных путей в случае провала поиска (например достигнута конечная неподходящая вершина или предел глубины).
Во втором правиле происходит сам поиск:
1. Проверить, если первый в очереди путь больше предела глубины (длина списка равна глубине, где список длины 1 – сам корень)
2. Составить все возможные удлинения пути и добавить их в конец очереди
3. Вызвать поиск на оставшуюся очередь.

#### Продление пути
```prolog
% First version
swap_adj(State, Res):-
    append(Left, [H1, H2 | T], State),
    H1 \= H2,
    append(Left, [H2, H1 | T], Res).  
```
В первой версии продления пути включались все возможные перестановки, включая перестановки обратно. Т.е. если рядом стояли два неодинаковых шара, то они менялсь местами и добавлялись как пути. Но такой случай создавал граф со слишком большим разветвлением: после корня (исходного состояния) появлялось еще 5 вершин (5 возможных перестановок), к этим вершинам добавлялось еще 4 вершины (т.е. 5 перестановок, не считая перестановку, возвращающую в прошлое состояние). Соответственно:
* на глубине 2 (после корня) есть 5 вершин,
* глубине 3 – 20 вершин,
* глубине 4 – 80 и т.д.

При больших перестановках (как в данном задании) это приводит к переполнению стека

Такая проблема решается двумя способами:
1. Изменения способа храниения состояний
2. Введения ограничений
Первый способ нельзя применить ввиду того, что нам необходимо знать положение каждого шарика относительно друг друга, и создание более обобщенного хранения невозможно. Соответственно остается ограничить продление пути.

Из задания следует, что белые шары должны идти влево, а черные – вправо. Соответственно перестановку можно модифицировать следующим образом:
```Prolog
swap_adj(State, Res):-
    append(Left, [H1, H2 | T], State),
    H1 = 'b',
    H2 = 'w',
    append(Left, [H2, H1 | T], Res).  
```

Такая перестановка не приводит к переполнению стека, но взамен она будет возвращать одни и те же пути разными способами.
В частности, такая перестановка напоминает сортировку пузырьком, реализация которой приложена к этой лабораторной работе.

## Результаты

Итого, поиск в ширину выводит самый короткий путь и, если убрать оператор отсечения, то он будет выводит его достижение разными способами.\
Поиск в глубину может выводить все пути не больше заданной границы, но они не будут самыми короткими.

| Алгоритм             |  Длина найденного первым пути  |  Время работы  |
|:--------------------:|:------------------------------:|:--------------:|
| Поиск в глубину      | 78                             | 40.030         |
| Поиск в ширину       | 14                             | 39.141         |
| Сортировка пузырьком | 14                             |  0.000         |

{Поиск с итерационным погружением?}

## Выводы

Двое самых простых поисков на графе: в глубину и в ширину – несмотря на то, что они ищут "вслепую", должны использоваться в зависимости от желаемого результата – поиск в глубину в случае, когда граф имеет слишком много ветвлений или необязательно, чтобы путь был коротким. Поиск в ширину используется для поиска самого короткого пути или когда известно, что искомая вершина находится в середине графа.\
Их отрицательные стороны состоят в том, что поиск глубину может искать слишком длинные пути, если ограничение глубины неизвестно, а поиск в ширину использует слишком много памяти при больших ветвлениях графа и без дополнительных параметров/ограничений может привести к переполнению стека программы.
